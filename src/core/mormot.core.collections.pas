/// Framework Core Low-Level Generics Collection Process
// - this unit is a part of the Open Source Synopse mORMot framework 2,
// licensed under a MPL/GPL/LGPL three license - see LICENSE.md
unit mormot.core.collections;

{
  *****************************************************************************

   Generics Collections as used by all framework units
   - JSON-aware IList<> List Storage
   - JSON-aware IKeyValue<> Dictionary Storage
   - TGenerics Factory for IList<> and IKeyValue<> Instances

    In respect to generics.collections, this unit uses interfaces as variable
   holders, and leverage them to reduce the generated code as much as possible,
   as the Spring4D 2.0 framework does, but for both Delphi and FPC.
    It also publishes TDynArray and TSynDictionary high-level features like
   JSON/binary serialization or thread safety with Generics strong typing.

  *****************************************************************************
}

interface

{$I ..\mormot.defines.inc}

{$ifdef HASGENERICS} // do-nothing unit on oldest compilers (e.g. < Delphi 2010)

uses
  classes,
  contnrs,
  sysutils,
  mormot.core.base,
  mormot.core.os,
  mormot.core.unicode,
  mormot.core.text,
  mormot.core.buffers,
  mormot.core.data,
  mormot.core.rtti,
  mormot.core.json;



{ ************** JSON-aware IList<> List Storage }

type
  /// interface to iterate over a generic collection of a specific type
  // - we redefined our own type because RTL IEnumerator<T> is inconsistent
  // between Delphi and FPC
  ISynEnumerator<T> = interface
    // some property accessor
    function GetCurrent: T;
    /// go to the next item iterated in this collection
    function MoveNext: boolean;
    /// returns the current item in this collection
    property Current: T
      read GetCurrent;
  end;

  /// interface to access a generic collection of a specific type
  // - we redefined our own type because RTL IEnumerable<T> is inconsistent
  // between Delphi and FPC
  ISynEnumerable<T> = interface
    /// allows to iterate over a generic collection of a specific type
    function GetEnumerator: ISynEnumerator<T>;
  end;

  /// exception class raised by IList<T>
  ESynList = class(ESynException);

  /// how TGenerics.NewList<T> will handle its IList<T> storage
  TSynListOptions = set of (
    aoCaseInsensitive);

  /// gives access to a generics-based collection of items
  // - as generated by TGenerics.NewList<T> main factory
  IList<T> = interface(ISynEnumerable<T>)
    // some property accessors
    function GetItem(ndx: PtrInt): T;
    procedure SetItem(ndx: PtrInt; const value: T);
    function GetCount: PtrInt;
    procedure SetCount(value: PtrInt);
    function GetCapacity: PtrInt;
    procedure SetCapacity(value: PtrInt);
    /// append a new value to the collection
    function Add(const value: T): PtrInt;
    /// insert a new value to the collection
    procedure Insert(ndx: PtrInt; const value: T);
    /// delete one item inside the collection
    // - the deleted item is finalized if necessary
    function Delete(ndx: PtrInt): boolean;
    /// get and remove the last item stored in the collection
    // - Add + Pop/Peek will implement a LIFO (Last-In-First-Out) stack
    // - returns true if the item was successfully copied and removed
    // - use Peek() if you don't want to remove the item
    function Pop(var dest: T): boolean;
    /// get the last item stored in the collection
    // - Add + Pop/Peek will implement a LIFO (Last-In-First-Out) stack
    // - returns true if the item was successfully copied into Dest
    // - use Pop() if you also want to remove the item
    function Peek(var dest: T): boolean;
    /// delete all stored items
    procedure Clear;
    /// high-level access to the stored values from their associated indexes
    // - returns nil or do nothing if the supplied index is out of range
    property Items[ndx: PtrInt]: T
      read GetItem write SetItem; default;
    /// low-level pointer over the first item of the collection
    // - could be used to quickly lookup all items of the array, using Count
    // - can be nil if there is no item stored yet
    function First: pointer;
    /// returns a dynamic array containing all data of this collection
    // - is a convenient way to consume such a list as regular SOA parameters
    function AsArray: TArray<T>;
    /// returns the number of items actually stored
    // - you can also set the Count value then fill it with Items[]
    property Count: PtrInt
      read GetCount write SetCount;
    /// returns the internal array capacity
    property Capacity: PtrInt
      read GetCapacity write SetCapacity;
    /// low-level access to the internal TDynArray wrapper
    // - you can use e.g. Data.SaveToJson/SaveTo and
    // Data.LoadFromJson/LoadFromBinary
    function Data: PDynArray;
  end;

  TSynGenericsAbstract = class(TInterfacedObject)
  protected
    class procedure RaiseException(const fmt: RawUtf8; const args: array of const);
  end;

  /// abstract parent of TSynListSpecialized<T> to reduce code size
  // - contains all fields and methods not explicitly related to type T
  TSynListAbstract = class(TSynGenericsAbstract)
  protected
    fCount: PtrInt;  // external TDynArray count
    fValue: pointer; // holds the actual dynamic array of <T>
    fDynArray: TDynArray;
    // some property accessors
    function GetCount: PtrInt;
    procedure SetCount(value: PtrInt);
    function GetCapacity: PtrInt;
    procedure SetCapacity(value: PtrInt);
  public
    /// initialize the array storage, specifying dynamic array type
    // - do not use this constructor, but TGenerics.NewList<T> class factory
    // - here aItemTypeInfo is required to be specified, since may not match T
    // - you can provide the dynamic array TypeInfo() of T if the types are too
    // complex, or not already registered to mormot.core.rtti
    // - by default, string values would be searched following exact case,
    // unless the aoCaseInsensitive option is set
    // - if aSortAs is ptNone, will guess the comparison/sort function from RTTI
    constructor Create(aOptions: TSynListOptions;
      aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; aSortAs: TRttiParserType);
    /// finalize the array storage, mainly the internal TDynArray
    destructor Destroy; override;
    /// delete one item inside the collection
    // - the deleted item is finalized if necessary
    function Delete(ndx: PtrInt): boolean;
    /// delete all stored items
    procedure Clear;
    /// low-level add an item to the dynamic array, returning its pointer
    function NewPtr: pointer;
    /// low-level pointer over the first item of the collection
    // - could be used to quickly lookup all items of the array, using Count
    // - can be nil if there is no item stored yet
    // - just a wrapper around fValue
    function First: pointer;
    /// returns the number of items actually stored
    property Count: PtrInt
      read fCount write SetCount;
    /// returns the internal array capacity
    property Capacity: PtrInt
      read GetCapacity write SetCapacity;
    /// low-level access to the internal TDynArray wrapper
    function Data: PDynArray;
  end;

  /// generics-based collection storage
  // - is a high level wrapper around our regular TDynArray
  // - main factory is TGenerics.NewList<T> class function, which returns a
  // IList<T> interface for reusing most class specializations: you should
  // NOT have to define a TSynListSpecialized<T> instance anywhere
  TSynListSpecialized<T> = class(TSynListAbstract, IList<T>)
  protected
    // some property accessors
    function GetItem(ndx: PtrInt): T;
    procedure SetItem(ndx: PtrInt; const value: T);
    /// allows to iterate over a generic collection of this specific type
    function GetEnumerator: ISynEnumerator<T>;
  public
    /// append a new value to the collection
    function Add(const value: T): PtrInt;
    /// insert a new value to the collection
    procedure Insert(ndx: PtrInt; const value: T);
    /// get and remove the last item stored in the collection
    // - Add + Pop/Peek will implement a LIFO (Last-In-First-Out) stack
    // - returns true if the item was successfully copied and removed
    // - use Peek() if you don't want to remove the item
    function Pop(var dest: T): boolean;
    /// get the last item stored in the collection
    // - Add + Pop/Peek will implement a LIFO (Last-In-First-Out) stack
    // - returns true if the item was successfully copied into Dest
    // - use Pop() if you also want to remove the item
    function Peek(var dest: T): boolean;
    /// returns a dynamic array containing all data of this collection
    // - is a convenient way to consume such a list as regular SOA parameters
    // - returns the current dynamic array stored in fValue with length = count
    function AsArray: TArray<T>;
    /// high-level access to the stored values from their associated indexes
    // - returns nil or do nothing if the supplied index is out of range
    property Items[ndx: PtrInt]: T
      read GetItem write SetItem; default;
  end;

  /// abstract parent of TSynEnumerator<T> to reduce code size
  // - contains all fields and methods not explicitly related to type T
  TSynEnumeratorAbstract = class(TInterfacedObject)
  protected
    fItemSize: PtrUInt;
    fCurrent, fAfter: PAnsiChar;
  public
    /// setup the enumerator class
    constructor Create(const Value: TSynListAbstract);
    /// go to the next item iterated in this collection
    function MoveNext: boolean; inline;
  end;

  /// process iteration over a ISynEnumerable<T> collection of a specific type
  TSynEnumerator<T> = class(TSynEnumeratorAbstract, ISynEnumerator<T>)
  protected
    type
      PT = ^T;
    // some property accessor
    function GetCurrent: T; inline;
  public
    /// returns the current item in this collection
    property Current: T
      read GetCurrent;
  end;




{ ************** JSON-aware IKeyValue<> Dictionary Storage }

// we defined "var value"  instead of "out value" to avoid finalizer calls

type
  /// exception class raised by TSynKeyValueSpecialized<TKey, TValue>
   ESynKeyValue = class(ESynException);

  /// gives access to a generics-based dictionary holding key/value pairs
  IKeyValue<TKey, TValue> = interface
    // some property accessors
    function GetItem(const key: TKey): TValue;
    procedure SetItem(const key: TKey; const value: TValue);
    function GetCapacity: integer;
    procedure SetCapacity(value: integer);
    function GetTimeOutSeconds: cardinal;
    procedure SetTimeOutSeconds(value: cardinal);
    /// add a key/value pair to be unique
    // - raise an  ESynKeyValue if key was already set
    // - use default Items[] property to add or replace a key/value pair
    procedure Add(const key: TKey; const value: TValue);
    /// add a key/value pair if key is not existing
    // - returns true if was added, false if key was already set
    // - use default Items[] property to add or replace a key/value pair
    function TryAdd(const key: TKey; const value: TValue): boolean;
    /// search a key and return the associated key pair
    // - returns true if the key was found, false otherwise
    function TryGetValue(const key: TKey; var value: TValue): boolean;
    /// search a key and return the associated key pair or its default value
    function GetValueOrDefault(const key: TKey): TValue; overload;
    /// search a key and return the associated key pair or a supplied default value
    function GetValueOrDefault(const key: TKey; const defaultValue: TValue): TValue; overload;
    /// remove a key/value pair
    // - returns true if the entry was deleted, false if key was not found
    function Remove(const key: TKey): boolean;
    /// search a key, get the associated value, then delete the key/value pair
    function Extract(const key: TKey; var value: TValue): boolean;
    /// search for a key/value pair from a key
    // - returns true if the key was found, false otherwise
    function ContainsKey(const key: TKey): boolean;
    /// search for a key/value pair from a value
    // - returns true if the value was found, false otherwise
    function ContainsValue(const value: TValue): boolean;
    /// search and delete all deprecated items according to TimeoutSeconds
    // - returns how many items have been deleted
    // - you can call this method very often: it will ensure that the
    // search process will take place at most once every second
    function DeleteDeprecated: integer;
    /// delete all stored key/value pairs
    procedure Clear; overload;
    /// delete one stored key/value pairs from its key
    function Clear(const key: TKey): boolean; overload;
    /// high-level access to the stored values from their associated keys
    // - raise an  ESynKeyValue if the key is not available, unless
    // kvoDefaultIfNotFound option was set
    // - use TryGetValue() if you want to detect non available key
    property Items[const key: TKey]: TValue
      read GetItem write SetItem; default;
    /// returns the number of key/value pairs actually stored
    function Count: integer;
    /// returns the internal TSynDictionary capacity
    property Capacity: integer
      read GetCapacity write SetCapacity;
    /// returns the aTimeOutSeconds parameter value, as specified to Create()
    // - warning: setting a new timeout will clear all previous content
    property TimeOutSeconds: cardinal
      read GetTimeOutSeconds write SetTimeOutSeconds;
    /// low-level access to the internal TSynDictionary storage
    // - since this class is thread-safe, you could use this method to
    // manually access its content
    // - you can use e.g. Data.SaveToJson/SaveToBinary and
    // Data.LoadFromJson/LoadFromBinary
    function Data: TSynDictionary;
  end;

  /// how TSynKeyValueSpecialized<TKey, TValue>.Create() will handle its storage
  TSynKeyValueOptions = set of (
    kvoKeyCaseInsensitive,
    kvoThreadSafe,
    kvoDefaultIfNotFound);

  /// stack parameters to ease TSynKeyValueSpecialized<TKey, TValue> creation
  TNewSynKeyValueContext = record
    Options: TSynKeyValueOptions;
    KeyArrayTypeInfo, KeyItemTypeInfo: PRttiInfo;
    ValueArrayTypeInfo, ValueItemTypeInfo: PRttiInfo;
    Timeout: cardinal;
    Compress: TAlgoCompress;
    Hasher: THasher;
  end;

  /// abstract parent of TSynKeyValueSpecialized<TKey, TValue> to reduce code size
  // - contains all fields and methods not explicitly related to TKey/TValue
  TSynKeyValueAbstract = class(TSynGenericsAbstract)
  protected
    fData: TSynDictionary;
    fKeyTypeInfo, fValueTypeInfo: PRttiInfo;
    fOptions: TSynKeyValueOptions;
    procedure AddOne(const key, value);
    procedure GetOne(const key; var value);
    procedure GetOneOrDefault(const key; var value);
    function GetCapacity: integer;
    procedure SetCapacity(value: integer);
    function GetTimeOutSeconds: cardinal;
    procedure SetTimeOutSeconds(value: cardinal);
  public
    /// initialize the dictionary storage, specifyng dynamic array keys/values
    // - you can provide the dynamic arrays TypeInfo() of TKey/TValue if the
    // types are too complex, or not already registered to mormot.core.rtti
    // - by default, this instance won't be thread-safe unless the kvoThreadSafe
    // option is forced, so that process is protected with a TSynLocker mutex
    // - by default, string keys would be searched following exact case, unless
    // the kvoKeyCaseInsensitive option is set
    // - you can set an optional timeout period, in seconds - you should call
    // DeleteDeprecated periodically to search for deprecated items
    constructor Create(const aContext: TNewSynKeyValueContext); reintroduce; virtual;
    /// finalize the dictionary storage
    destructor Destroy; override;
    /// search and delete all deprecated items according to TimeoutSeconds
    // - returns how many items have been deleted
    // - you can call this method very often: it will ensure that the
    // search process will take place at most once every second
    function DeleteDeprecated: integer;
    /// delete all stored key/value pairs
    procedure Clear; overload;
    /// returns the number of key/value pairs actually stored
    function Count: integer;
    /// returns the internal TSynDictionary capacity
    property Capacity: integer
      read GetCapacity write SetCapacity;
    /// returns the aTimeOutSeconds parameter value, as supplied to Create()
    // - warning: setting a new timeout will clear all previous content
    property TimeOutSeconds: cardinal
      read GetTimeOutSeconds write SetTimeOutSeconds;
    /// low-level access to the internal TSynDictionary storage
    // - since this class is thread-safe, you could use this method to
    // manually access its content
    // - you can use e.g. Data.SaveToJson/SaveToBinary and
    // Data.LoadFromJson/LoadFromBinary
    function Data: TSynDictionary; inline;
    /// low-level access to the TSynKeyValueOptions as supplied to Create()
    property Options: TSynKeyValueOptions
      read fOptions;
    /// low-level access to TypeInfo(TKey) - match fData.Keys.Info as array
    property KeyTypeInfo: PRttiInfo
      read fKeyTypeInfo;
    /// low-level access to TypeInfo(TValue) - match fData.Values.Info as array
    property ValueTypeInfo: PRttiInfo
      read fValueTypeInfo;
  end;

  /// thread-safe generics-based dictionary holding key/value pairs
  // - is a high level wrapper around our regular TSynDictionary
  // - could be accessed from an IKeyValue<TKey, TValue> interface for
  // automatic reference counting and memory management
  TSynKeyValueSpecialized<TKey, TValue> = class(TSynKeyValueAbstract, IKeyValue<TKey, TValue>)
  protected
    // some property accessors
    function GetItem(const key: TKey): TValue;
    procedure SetItem(const key: TKey; const value: TValue);
  public
    { IKeyValue<TKey, TValue> methods }
    /// add a key/value pair to be unique
    // - raise an  ESynKeyValue if key was already set
    // - use default Items[] property to add or replace a key/value pair
    procedure Add(const key: TKey; const value: TValue);
    /// add a key/value pair if key is not existing
    // - returns true if was added, false if key was already set
    // - use default Items[] property to add or replace a key/value pair
    function TryAdd(const key: TKey; const value: TValue): boolean;
    /// search a key and return the associated key pair
    // - returns true if the key was found, false otherwise
    function TryGetValue(const key: TKey; var value: TValue): boolean;
    /// search a key and return the associated key pair or its default value
    function GetValueOrDefault(const key: TKey): TValue; overload;
    /// search a key and return the associated key pair or a supplied default value
    function GetValueOrDefault(const key: TKey;
      const defaultValue: TValue): TValue; overload;
    /// remove a key/value pair
    // - returns true if the entry was deleted, false if key was not found
    function Remove(const key: TKey): boolean;
    /// search a key, get the associated value, then delete the key/value pair
    function Extract(const key: TKey; var value: TValue): boolean;
    /// search for a key/value pair from a key
    // - returns true if the key was found, false otherwise
    function ContainsKey(const key: TKey): boolean;
    /// search for a key/value pair from a value
    // - returns true if the value was found, false otherwise
    function ContainsValue(const value: TValue): boolean;
    /// delete one stored key/value pairs from its key
    function Clear(const key: TKey): boolean; overload;
    /// high-level access to the stored values from their associated keys
    // - raise an  ESynKeyValue if the key is not available, unless
    // kvoDefaultIfNotFound option was set
    // - use TryGetValue/GetValueOrDefault to detect non available key
    property Items[const key: TKey]: TValue
      read GetItem write SetItem; default;
  end;



{ ************ TGenerics Factory for IList<> and IKeyValue<> Instances }

type
  /// various factories to create instances of our generic collections
  // - this is main entry point of mormot.core.collections unit
  // - you should never call TSynListSpecialized<T>.Create nor
  // TSynKeyValueSpecialized<T>.Create constructors, but the static
  // methods of this class
  TGenerics = class
  protected
    {$ifdef HASGETTYPEKIND}
    // dedicated factories for most common TSynListSpecialized<T> types
    class procedure NewOrdinal(aSize: integer; aOptions: TSynListOptions;
      aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; var result); static;
    class procedure NewLString(aOptions: TSynListOptions;
      aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; var result); static;
    class procedure NewWString(aOptions: TSynListOptions;
      aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; var result); static;
    class procedure NewUString(aOptions: TSynListOptions;
      aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; var result); static;
    class procedure NewInterface(aOptions: TSynListOptions;
      aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; var result); static;
    class procedure NewVariant(aOptions: TSynListOptions;
      aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; var result); static;
    // dedicated factories for most common TSynListSpecialized<T> types
    class procedure NewOrdinalOrdinal(const aContext: TNewSynKeyValueContext;
      aSizeKey, aSizeValue: integer; var result); static;
    class procedure NewOrdinalLString(const aContext: TNewSynKeyValueContext;
      aSizeKey: integer; var result); static;
    class procedure NewOrdinalWString(const aContext: TNewSynKeyValueContext;
      aSizeKey: integer; var result); static;
    class procedure NewOrdinalUString(const aContext: TNewSynKeyValueContext;
      aSizeKey: integer; var result); static;
    class procedure NewOrdinalInterface(const aContext: TNewSynKeyValueContext;
      aSizeKey: integer; var result); static;
    class procedure NewOrdinalVariant(const aContext: TNewSynKeyValueContext;
      aSizeKey: integer; var result); static;
    class procedure NewLStringOrdinal(const aContext: TNewSynKeyValueContext;
      aSizeValue: integer; var result); static;
    class procedure NewLStringValue(const aContext: TNewSynKeyValueContext;
      aValue: TTypeKind; var result); static;
    class procedure NewWStringOrdinal(const aContext: TNewSynKeyValueContext;
      aSizeValue: integer; var result); static;
    class procedure NewWStringValue(const aContext: TNewSynKeyValueContext;
      aValue: TTypeKind; var result); static;
    class procedure NewUStringOrdinal(const aContext: TNewSynKeyValueContext;
      aSizeValue: integer; var result); static;
    class procedure NewUStringValue(const aContext: TNewSynKeyValueContext;
      aValue: TTypeKind; var result); static;
    class procedure NewInterfaceOrdinal(const aContext: TNewSynKeyValueContext;
      aSizeValue: integer; var result); static;
    class procedure NewInterfaceValue(const aContext: TNewSynKeyValueContext;
      aValue: TTypeKind; var result); static;
    class procedure NewVariantOrdinal(const aContext: TNewSynKeyValueContext;
      aSizeValue: integer; var result); static;
    class procedure NewVariantValue(const aContext: TNewSynKeyValueContext;
      aValue: TTypeKind; var result); static;
    {$endif HASGETTYPEKIND}
    // the RTTI is too complex -> should call NewPlain*<>() methods instead
    class function RaiseUseNewPlainList(aItemTypeInfo: PRttiInfo): pointer; static;
    class function RaiseUseNewPlainKeyValue(
      const aContext: TNewSynKeyValueContext): pointer; static;
  public
    /// generate a new IList<T> instance
    // - use this factory method instead of plain TSynListSpecialized<T>.Create
    // so that the types will be specifialized and compiled once in this unit
    // - you can provide the dynamic array TypeInfo() of T if the types are too
    // complex, or not already registered to mormot.core.rtti
    // - raise ESynList if T type is too complex: use NewPlainList<T>() instead
    class function NewList<T>(aOptions: TSynListOptions = [];
      aDynArrayTypeInfo: PRttiInfo = nil): IList<T>; static; inline;
    /// generate a new IList<T> instance with exact TSynListSpecialized<T>
    // - to be called for complex types (e.g. managed records) when
    // NewList<T> fails and triggers ESynList
    class function NewPlainList<T>(aOptions: TSynListOptions = [];
      aDynArrayTypeInfo: PRttiInfo = nil): IList<T>; static; inline;
    /// generate a new IKeyValue<TKey, TValue> instance
    // - use this factory method instead of TSynKeyValueSpecialized<>.Create
    // so that the types will be specifialized and compiled once in this unit
    // - you can provide the dynamic array TypeInfo() of T if the types are too
    // complex, or not already registered to mormot.core.rtti
    // - raise ESynKeyValue if T type is too complex: use NewPlainList<T>() instead
    class function NewKeyValue<TKey, TValue>(aOptions: TSynKeyValueOptions = [];
      aKeyDynArrayTypeInfo: PRttiInfo = nil; aValueDynArrayTypeInfo: PRttiInfo = nil;
      aTimeoutSeconds: cardinal = 0; aCompressAlgo: TAlgoCompress = nil;
      aHasher: THasher = nil): IKeyValue<TKey, TValue>; static; inline;
    /// generate a new IKeyValue<TKey, TValue> instance with exact
    // TSynKeyValueSpecialized<TKey, TValue>
    // - to be called for complex types (e.g. managed records) when
    // NewKeyValue<TKey, TValue> fails and triggers ESynKeyValue
    class function NewPlainKeyValue<TKey, TValue>(aOptions: TSynKeyValueOptions = [];
      aKeyDynArrayTypeInfo: PRttiInfo = nil; aValueDynArrayTypeInfo: PRttiInfo = nil;
      aTimeoutSeconds: cardinal = 0; aCompressAlgo: TAlgoCompress = nil;
      aHasher: THasher = nil): IKeyValue<TKey, TValue>; static; inline;
  end;


implementation


{ ************** JSON-aware IList<> List Storage }

{ TSynEnumeratorAbstract }

constructor TSynEnumeratorAbstract.Create(const Value: TSynListAbstract);
begin
  fCurrent := Value.fValue;
  if fCurrent <> nil then
  begin
    fItemSize := Value.fDynArray.Info.Cache.ItemSize;
    fAfter := fCurrent + fItemSize * PtrUInt(Value.fCount);
  end;
end;

function TSynEnumeratorAbstract.MoveNext: boolean;
var
  c: PtrUInt;
begin
  c := fItemSize;
  inc(fCurrent, c);
  inc(c, PtrUInt(fCurrent));
  result := c < PtrUInt(fAfter);
end;


{ TSynEnumerator }

function TSynEnumerator<T>.GetCurrent: T;
begin
  result := PT(fCurrent)^; // faster than fDynArray^.ItemCopy()
end;


{ TSynGenericsAbstract }

class procedure TSynGenericsAbstract.RaiseException(const fmt: RawUtf8;
  const args: array of const);
var
  msg: ShortString;
begin
  FormatShort(fmt, args, msg);
  raise ESynKeyValue.CreateUtf8('%.%', [self, msg])
    {$ifdef ISDELPHIXE4} at ReturnAddress {$endif};
end;


{ TSynListAbstract }

constructor TSynListAbstract.Create(aOptions: TSynListOptions;
  aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; aSortAs: TRttiParserType);
var
  r: PRttiInfo;
begin
  r := aDynArrayTypeInfo;
  if r = nil then
    r := TypeInfoToDynArrayTypeInfo(aItemTypeInfo, {exact=}false);
  if (r = nil) or
     (r ^.Kind <> rkDynArray) then
     RaiseException('Create: % should be a dynamic array of T', [r^.Name^]);
  fDynArray.InitSpecific(r, fValue, aSortAs, // aSortAs=ptNone = use RTTI
    @fCount, aoCaseInsensitive in aOptions);
  if (fDynArray.Info.ArrayRtti = nil) or
     ((aDynArrayTypeInfo <> nil) and
      (fDynArray.Info.ArrayRtti.Info <> aItemTypeInfo)) then
    RaiseException('Create: T does not match %', [aDynArrayTypeInfo.RawName]);
end;

destructor TSynListAbstract.Destroy;
begin
  inherited Destroy;
  fDynArray.Clear;
end;

function TSynListAbstract.Delete(ndx: PtrInt): boolean;
begin
  result := fDynArray.Delete(ndx);
end;

function TSynListAbstract.GetCount: PtrInt;
begin
  result := fCount;
end;

procedure TSynListAbstract.SetCount(value: PtrInt);
begin
  fDynArray.Count := value; // will resize the dynamic array
end;

function TSynListAbstract.GetCapacity: PtrInt;
begin
  result := fDynArray.Capacity;
end;

procedure TSynListAbstract.SetCapacity(value: PtrInt);
begin
  fDynArray.Capacity := value; // don't change Count, just dynamic array length
end;

procedure TSynListAbstract.Clear;
begin
  fDynArray.Clear;
end;

function TSynListAbstract.NewPtr: pointer;
begin
  result := fDynArray.NewPtr;
end;

function TSynListAbstract.First: pointer;
begin
  result := fValue;
end;

function TSynListAbstract.Data: PDynArray;
begin
  result := @fDynArray;
end;


{ TSynListSpecialized }

function TSynListSpecialized<T>.GetItem(ndx: PtrInt): T;
begin
  if PtrUInt(ndx) < PtrUInt(fCount) then
    result := TArray<T>(fValue)[ndx]
  else
    result := Default(T);
end;

procedure TSynListSpecialized<T>.SetItem(ndx: PtrInt; const value: T);
begin
  if PtrUInt(ndx) < PtrUInt(fCount) then
    TArray<T>(fValue)[ndx] := value;
end;

function TSynListSpecialized<T>.GetEnumerator: ISynEnumerator<T>;
begin
  result := TSynEnumerator<T>.Create(self);
end;

function TSynListSpecialized<T>.Add(const value: T): PtrInt;
begin
  result := fDynArray.Add(value);
end;

procedure TSynListSpecialized<T>.Insert(ndx: PtrInt; const value: T);
begin
  fDynArray.Insert(ndx, value);
end;

function TSynListSpecialized<T>.Pop(var dest: T): boolean;
begin
  result := fDynArray.Pop(dest);
end;

function TSynListSpecialized<T>.Peek(var dest: T): boolean;
begin
  result := fDynArray.Peek(dest);
end;

function TSynListSpecialized<T>.AsArray: TArray<T>;
begin // assign existing dynamic array instance to TArray<T> result
  fDynArray.SliceAsDynArray(@result);
end;



{ ************** JSON-aware IKeyValue<> Dictionary Storage }

{ TSynKeyValueAbstract }

// shared methods leveraged against all TSynKeyValueSpecialized<> to reduce exe code size

constructor TSynKeyValueAbstract.Create(const aContext: TNewSynKeyValueContext);
var
  k, v: PRttiInfo;
begin
  fOptions := aContext.Options;
  fKeyTypeInfo := aContext.KeyItemTypeInfo;
  fValueTypeInfo := aContext.ValueItemTypeInfo;
  // validate or recognize most simple dynamic arrays from its TKey/TValue types
  k := aContext.KeyArrayTypeInfo;
  if k = nil then
    k := TypeInfoToDynArrayTypeInfo(fKeyTypeInfo, {exact=}false);
  if (k = nil) or
     (k ^.Kind <> rkDynArray) then
     RaiseException('Create: % should be a dynamic array of TKey', [k^.Name^]);
  v := aContext.ValueArrayTypeInfo;
  if v = nil then
    v := TypeInfoToDynArrayTypeInfo(fValueTypeInfo, {exact=}false);
  if (v = nil) or
     (v^.Kind <> rkDynArray) then
     RaiseException('Create: % should be a dynamic array of TValue', [v^.Name^]);
  // initialize the associated dictionary
  fData := TSynDictionary.Create(k, v, kvoKeyCaseInsensitive in fOptions,
    aContext.Timeout, aContext.Compress, aContext.Hasher);
  if kvoThreadSafe in fOptions then
    fData.Options := [doSingleThreaded];
  if (fData.Keys.Info.ArrayRtti = nil) or
     ((aContext.KeyArrayTypeInfo <> nil) and
      (fData.Keys.Info.ArrayRtti.Info <> fKeyTypeInfo)) then
    RaiseException('Create: TKey does not match %',
      [aContext.KeyArrayTypeInfo^.RawName]);
  if (fData.Values.Info.ArrayRtti = nil) or
     ((aContext.ValueArrayTypeInfo <> nil) and
      (fData.Values.Info.ArrayRtti.Info <> fValueTypeInfo)) then
    RaiseException('Create: TValue does not match %',
      [aContext.ValueArrayTypeInfo^.RawName]);
end;

destructor TSynKeyValueAbstract.Destroy;
begin
  inherited Destroy;
  fData.Free;
end;

procedure TSynKeyValueAbstract.AddOne(const key, value);
begin
  if fData.Add(key, value) < 0 then
    RaiseException('Add: duplicated key', []);
end;

procedure TSynKeyValueAbstract.GetOne(const key; var value);
begin
  if not fData.FindAndCopy(key, value) then
    if kvoDefaultIfNotFound in fOptions then
      fData.Values.ItemClear(@value)
    else
      RaiseException('GetItem: key not found', []);
end;

procedure TSynKeyValueAbstract.GetOneOrDefault(const key; var value);
begin
  if not fData.FindAndCopy(key, value) then
    fData.Values.ItemClear(@value);
end;

function TSynKeyValueAbstract.GetCapacity: integer;
begin
  result := fData.Capacity;
end;

procedure TSynKeyValueAbstract.SetCapacity(value: integer);
begin
  fData.Capacity := value;
end;

function TSynKeyValueAbstract.GetTimeOutSeconds: cardinal;
begin
  result := fData.TimeOutSeconds;
end;

procedure TSynKeyValueAbstract.SetTimeOutSeconds(value: cardinal);
begin
  fData.TimeOutSeconds := value;
end;

function TSynKeyValueAbstract.DeleteDeprecated: integer;
begin
  result := fData.DeleteDeprecated;
end;

procedure TSynKeyValueAbstract.Clear;
begin
  fData.DeleteAll;
end;

function TSynKeyValueAbstract.Count: integer;
begin
  result := fData.Count;
end;

function TSynKeyValueAbstract.Data: TSynDictionary;
begin
  result := fData;
end;


{ TSynKeyValueSpecialized<TKey, TValue> }

function TSynKeyValueSpecialized<TKey, TValue>.GetItem(const key: TKey): TValue;
begin
  GetOne(key, result);
end;

procedure TSynKeyValueSpecialized<TKey, TValue>.SetItem(const key: TKey;
  const value: TValue);
begin
  fData.AddOrUpdate(key, value);
end;

procedure TSynKeyValueSpecialized<TKey, TValue>.Add(const key: TKey; const value: TValue);
begin
  AddOne(key, value);
end;

function TSynKeyValueSpecialized<TKey, TValue>.TryAdd(const key: TKey;
  const value: TValue): boolean;
begin
  result := fData.Add(key, value) >= 0;
end;

function TSynKeyValueSpecialized<TKey, TValue>.TryGetValue(const key: TKey;
  var value: TValue): boolean;
begin
  result := fData.FindAndCopy(key, value);
end;

function TSynKeyValueSpecialized<TKey, TValue>.GetValueOrDefault(const key: TKey): TValue;
begin
  GetOneOrDefault(key, result);
end;

function TSynKeyValueSpecialized<TKey, TValue>.GetValueOrDefault(const key: TKey;
  const defaultValue: TValue): TValue;
begin
  if not fData.FindAndCopy(key, result) then
    result := defaultValue;
end;

function TSynKeyValueSpecialized<TKey, TValue>.Remove(const key: TKey): boolean;
begin
  result := fData.Delete(key) >= 0;
end;

function TSynKeyValueSpecialized<TKey, TValue>.Extract(const key: TKey;
  var value: TValue): boolean;
begin
  result := fData.FindAndExtract(key, value);
end;

function TSynKeyValueSpecialized<TKey, TValue>.ContainsKey(const key: TKey): boolean;
begin
  result := fData.Exists(key);
end;

function TSynKeyValueSpecialized<TKey, TValue>.ContainsValue(const value: TValue): boolean;
begin
  result := fData.ExistsValue(value);
end;

function TSynKeyValueSpecialized<TKey, TValue>.Clear(const key: TKey): boolean;
begin
  result := fData.Clear(key) >= 0;
end;



{ ************ TGenerics Factory for IList<> and IKeyValue<> Instances }

{ TGenerics }

class function TGenerics.RaiseUseNewPlainList(aItemTypeInfo: PRttiInfo): pointer;
begin
  raise ESynList.CreateUtf8(
    'TGenerics: Type is too complex - use TGenerics.NewPlainList<%> instead',
    [aItemTypeInfo.RawName])
    {$ifdef ISDELPHIXE4} at ReturnAddress {$endif};
  result := nil; // returns something to please the Delphi compiler
end;

class function TGenerics.RaiseUseNewPlainKeyValue(
  const aContext: TNewSynKeyValueContext): pointer;
begin
  raise ESynKeyValue.CreateUtf8('TGenerics: Types are too complex - ' +
    'use TGenerics.NewPlainKeyValue<%, %> instead',
    [aContext.KeyItemTypeInfo.RawName, aContext.ValueItemTypeInfo.RawName])
    {$ifdef ISDELPHIXE4} at ReturnAddress {$endif};
  result := nil; // returns something to please the Delphi compiler
end;

{$ifdef HASGETTYPEKIND}

class procedure TGenerics.NewOrdinalOrdinal(
  const aContext: TNewSynKeyValueContext; aSizeKey, aSizeValue: integer;
  var result);
var
  obj: pointer;
label
  err;
begin
  case aSizeKey of
    1:
      case aSizeValue of
        1:
          obj := TSynKeyValueSpecialized<Byte, Byte>.Create(aContext);
        2:
          obj := TSynKeyValueSpecialized<Byte, Word>.Create(aContext);
        4:
          obj := TSynKeyValueSpecialized<Byte, Integer>.Create(aContext);
        8:
          obj := TSynKeyValueSpecialized<Byte, Int64>.Create(aContext);
        16:
          obj := TSynKeyValueSpecialized<Byte, THash128>.Create(aContext);
      else
err:    obj := RaiseUseNewPlainKeyValue(aContext);
      end;
    2:
      case aSizeValue of
        1:
          obj := TSynKeyValueSpecialized<Word, Byte>.Create(aContext);
        2:
          obj := TSynKeyValueSpecialized<Word, Word>.Create(aContext);
        4:
          obj := TSynKeyValueSpecialized<Word, Integer>.Create(aContext);
        8:
          obj := TSynKeyValueSpecialized<Word, Int64>.Create(aContext);
        16:
          obj := TSynKeyValueSpecialized<Word, THash128>.Create(aContext);
      else
        goto err;
      end;
    4:
      case aSizeValue of
        1:
          obj := TSynKeyValueSpecialized<Integer, Byte>.Create(aContext);
        2:
          obj := TSynKeyValueSpecialized<Integer, Word>.Create(aContext);
        4:
          obj := TSynKeyValueSpecialized<Integer, Integer>.Create(aContext);
        8:
          obj := TSynKeyValueSpecialized<Integer, Int64>.Create(aContext);
        16:
          obj := TSynKeyValueSpecialized<Integer, THash128>.Create(aContext);
      else
        goto err;
      end;
    8:
      case aSizeValue of
        1:
          obj := TSynKeyValueSpecialized<Int64, Byte>.Create(aContext);
        2:
          obj := TSynKeyValueSpecialized<Int64, Word>.Create(aContext);
        4:
          obj := TSynKeyValueSpecialized<Int64, Integer>.Create(aContext);
        8:
          obj := TSynKeyValueSpecialized<Int64, Int64>.Create(aContext);
        16:
          obj := TSynKeyValueSpecialized<Int64, THash128>.Create(aContext);
      else
        goto err;
      end;
    16:
      case aSizeValue of
        1:
          obj := TSynKeyValueSpecialized<THash128, Byte>.Create(aContext);
        2:
          obj := TSynKeyValueSpecialized<THash128, Word>.Create(aContext);
        4:
          obj := TSynKeyValueSpecialized<THash128, Integer>.Create(aContext);
        8:
          obj := TSynKeyValueSpecialized<THash128, Int64>.Create(aContext);
        16:
          obj := TSynKeyValueSpecialized<THash128, THash128>.Create(aContext);
      else
        goto err;
      end;
  else
    goto err;
  end;
  // all IKeyValue<TKey, TValue> share the same VMT -> assign once
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure TGenerics.NewOrdinalLString(
  const aContext: TNewSynKeyValueContext; aSizeKey: integer; var result);
var
  obj: pointer;
begin
  case aSizeKey of
    1:
      obj := TSynKeyValueSpecialized<Byte, IInterface>.Create(aContext);
    2:
      obj := TSynKeyValueSpecialized<Word, IInterface>.Create(aContext);
    4:
      obj := TSynKeyValueSpecialized<Integer, IInterface>.Create(aContext);
    8:
      obj := TSynKeyValueSpecialized<Int64, IInterface>.Create(aContext);
    16:
      obj := TSynKeyValueSpecialized<THash128, IInterface>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure TGenerics.NewOrdinalWString(
  const aContext: TNewSynKeyValueContext; aSizeKey: integer; var result);
var
  obj: pointer;
begin
  case aSizeKey of
    1:
      obj := TSynKeyValueSpecialized<Byte, WideString>.Create(aContext);
    2:
      obj := TSynKeyValueSpecialized<Word, WideString>.Create(aContext);
    4:
      obj := TSynKeyValueSpecialized<Integer, WideString>.Create(aContext);
    8:
      obj := TSynKeyValueSpecialized<Int64, WideString>.Create(aContext);
    16:
      obj := TSynKeyValueSpecialized<THash128, WideString>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure TGenerics.NewOrdinalUString(
  const aContext: TNewSynKeyValueContext; aSizeKey: integer; var result);
var
  obj: pointer;
begin
  case aSizeKey of
    1:
      obj := TSynKeyValueSpecialized<Byte, UnicodeString>.Create(aContext);
    2:
      obj := TSynKeyValueSpecialized<Word, UnicodeString>.Create(aContext);
    4:
      obj := TSynKeyValueSpecialized<Integer, UnicodeString>.Create(aContext);
    8:
      obj := TSynKeyValueSpecialized<Int64, UnicodeString>.Create(aContext);
    16:
      obj := TSynKeyValueSpecialized<THash128, UnicodeString>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure TGenerics.NewOrdinalInterface(
  const aContext: TNewSynKeyValueContext; aSizeKey: integer; var result);
var
  obj: pointer;
begin
  case aSizeKey of
    1:
      obj := TSynKeyValueSpecialized<Byte, IInterface>.Create(aContext);
    2:
      obj := TSynKeyValueSpecialized<Word, IInterface>.Create(aContext);
    4:
      obj := TSynKeyValueSpecialized<Integer, IInterface>.Create(aContext);
    8:
      obj := TSynKeyValueSpecialized<Int64, IInterface>.Create(aContext);
    16:
      obj := TSynKeyValueSpecialized<THash128, IInterface>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure TGenerics.NewOrdinalVariant(
  const aContext: TNewSynKeyValueContext; aSizeKey: integer; var result);
var
  obj: pointer;
begin
  case aSizeKey of
    1:
      obj := TSynKeyValueSpecialized<Byte, Variant>.Create(aContext);
    2:
      obj := TSynKeyValueSpecialized<Word, Variant>.Create(aContext);
    4:
      obj := TSynKeyValueSpecialized<Integer, Variant>.Create(aContext);
    8:
      obj := TSynKeyValueSpecialized<Int64, Variant>.Create(aContext);
    16:
      obj := TSynKeyValueSpecialized<THash128, Variant>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure TGenerics.NewLStringOrdinal(
  const aContext: TNewSynKeyValueContext; aSizeValue: integer; var result);
var
  obj: pointer;
begin
  case aSizeValue of
    1:
      obj := TSynKeyValueSpecialized<IInterface, Byte>.Create(aContext);
    2:
      obj := TSynKeyValueSpecialized<IInterface, Word>.Create(aContext);
    4:
      obj := TSynKeyValueSpecialized<IInterface, Integer>.Create(aContext);
    8:
      obj := TSynKeyValueSpecialized<IInterface, Int64>.Create(aContext);
    16:
      obj := TSynKeyValueSpecialized<IInterface, THash128>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure TGenerics.NewLStringValue(
  const aContext: TNewSynKeyValueContext; aValue: TTypeKind; var result);
var
  obj: pointer;
begin
  case aValue of
    {$ifdef FPC} tkAString {$else} tkLString {$endif FPC}:
      obj := TSynKeyValueSpecialized<IInterface, RawByteString>.Create(aContext);
    tkWString:
      obj := TSynKeyValueSpecialized<IInterface, WideString>.Create(aContext);
    tkUString:
      obj := TSynKeyValueSpecialized<IInterface, UnicodeString>.Create(aContext);
    tkInterface:
      obj := TSynKeyValueSpecialized<IInterface, IInterface>.Create(aContext);
    tkVariant:
      obj := TSynKeyValueSpecialized<IInterface, Variant>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure TGenerics.NewWStringOrdinal(
  const aContext: TNewSynKeyValueContext; aSizeValue: integer; var result);
var
  obj: pointer;
begin
  case aSizeValue of
    1:
      obj := TSynKeyValueSpecialized<WideString, Byte>.Create(aContext);
    2:
      obj := TSynKeyValueSpecialized<WideString, Word>.Create(aContext);
    4:
      obj := TSynKeyValueSpecialized<WideString, Integer>.Create(aContext);
    8:
      obj := TSynKeyValueSpecialized<WideString, Int64>.Create(aContext);
    16:
      obj := TSynKeyValueSpecialized<WideString, THash128>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure TGenerics.NewWStringValue(
  const aContext: TNewSynKeyValueContext; aValue: TTypeKind; var result);
var
  obj: pointer;
begin
  case aValue of
    {$ifdef FPC} tkAString {$else} tkLString {$endif FPC}:
      obj := TSynKeyValueSpecialized<WideString, RawByteString>.Create(aContext);
    tkWString:
      obj := TSynKeyValueSpecialized<WideString, WideString>.Create(aContext);
    tkUString:
      obj := TSynKeyValueSpecialized<WideString, UnicodeString>.Create(aContext);
    tkInterface:
      obj := TSynKeyValueSpecialized<WideString, IInterface>.Create(aContext);
    tkVariant:
      obj := TSynKeyValueSpecialized<WideString, Variant>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure TGenerics.NewUStringOrdinal(
  const aContext: TNewSynKeyValueContext; aSizeValue: integer; var result);
var
  obj: pointer;
begin
  case aSizeValue of
    1:
      obj := TSynKeyValueSpecialized<UnicodeString, Byte>.Create(aContext);
    2:
      obj := TSynKeyValueSpecialized<UnicodeString, Word>.Create(aContext);
    4:
      obj := TSynKeyValueSpecialized<UnicodeString, Integer>.Create(aContext);
    8:
      obj := TSynKeyValueSpecialized<UnicodeString, Int64>.Create(aContext);
    16:
      obj := TSynKeyValueSpecialized<UnicodeString, THash128>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure TGenerics.NewUStringValue(
  const aContext: TNewSynKeyValueContext; aValue: TTypeKind; var result);
var
  obj: pointer;
begin
  case aValue of
    {$ifdef FPC} tkAString {$else} tkLString {$endif FPC}:
      obj := TSynKeyValueSpecialized<UnicodeString, RawByteString>.Create(aContext);
    tkWString:
      obj := TSynKeyValueSpecialized<UnicodeString, WideString>.Create(aContext);
    tkUString:
      obj := TSynKeyValueSpecialized<UnicodeString, UnicodeString>.Create(aContext);
    tkInterface:
      obj := TSynKeyValueSpecialized<UnicodeString, IInterface>.Create(aContext);
    tkVariant:
      obj := TSynKeyValueSpecialized<UnicodeString, Variant>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure TGenerics.NewInterfaceOrdinal(
  const aContext: TNewSynKeyValueContext; aSizeValue: integer; var result);
var
  obj: pointer;
begin
  case aSizeValue of
    1:
      obj := TSynKeyValueSpecialized<IInterface, Byte>.Create(aContext);
    2:
      obj := TSynKeyValueSpecialized<IInterface, Word>.Create(aContext);
    4:
      obj := TSynKeyValueSpecialized<IInterface, Integer>.Create(aContext);
    8:
      obj := TSynKeyValueSpecialized<IInterface, Int64>.Create(aContext);
    16:
      obj := TSynKeyValueSpecialized<IInterface, THash128>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure TGenerics.NewInterfaceValue(
  const aContext: TNewSynKeyValueContext; aValue: TTypeKind; var result);
var
  obj: pointer;
begin
  case aValue of
    {$ifdef FPC} tkAString {$else} tkLString {$endif FPC}:
      obj := TSynKeyValueSpecialized<IInterface, RawByteString>.Create(aContext);
    tkWString:
      obj := TSynKeyValueSpecialized<IInterface, WideString>.Create(aContext);
    tkUString:
      obj := TSynKeyValueSpecialized<IInterface, UnicodeString>.Create(aContext);
    tkInterface:
      obj := TSynKeyValueSpecialized<IInterface, IInterface>.Create(aContext);
    tkVariant:
      obj := TSynKeyValueSpecialized<IInterface, Variant>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;
class procedure TGenerics.NewVariantOrdinal(
  const aContext: TNewSynKeyValueContext; aSizeValue: integer; var result);
var
  obj: pointer;
begin
  case aSizeValue of
    1:
      obj := TSynKeyValueSpecialized<Variant, Byte>.Create(aContext);
    2:
      obj := TSynKeyValueSpecialized<Variant, Word>.Create(aContext);
    4:
      obj := TSynKeyValueSpecialized<Variant, Integer>.Create(aContext);
    8:
      obj := TSynKeyValueSpecialized<Variant, Int64>.Create(aContext);
    16:
      obj := TSynKeyValueSpecialized<Variant, THash128>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure TGenerics.NewVariantValue(
  const aContext: TNewSynKeyValueContext; aValue: TTypeKind; var result);
var
  obj: pointer;
begin
  case aValue of
    {$ifdef FPC} tkAString {$else} tkLString {$endif FPC}:
      obj := TSynKeyValueSpecialized<Variant, RawByteString>.Create(aContext);
    tkWString:
      obj := TSynKeyValueSpecialized<Variant, WideString>.Create(aContext);
    tkUString:
      obj := TSynKeyValueSpecialized<Variant, UnicodeString>.Create(aContext);
    tkInterface:
      obj := TSynKeyValueSpecialized<Variant, IInterface>.Create(aContext);
    tkVariant:
      obj := TSynKeyValueSpecialized<Variant, Variant>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;


// generate the most common types in this very unit

class procedure TGenerics.NewOrdinal(aSize: integer; aOptions: TSynListOptions;
  aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; var result);
var
  obj: pointer;
begin
  case aSize of
    1:
      obj := TSynListSpecialized<Byte>.Create(
        aOptions, aDynArrayTypeInfo, aItemTypeInfo, ptNone);
    2:
      obj := TSynListSpecialized<Word>.Create(
        aOptions, aDynArrayTypeInfo, aItemTypeInfo, ptNone);
    4:
      obj := TSynListSpecialized<Integer>.Create(
        aOptions, aDynArrayTypeInfo, aItemTypeInfo, ptNone);
    8:
      obj := TSynListSpecialized<Int64>.Create(
        aOptions, aDynArrayTypeInfo, aItemTypeInfo, ptNone);
    16:
      obj := TSynListSpecialized<THash128>.Create(
        aOptions, aDynArrayTypeInfo, aItemTypeInfo, ptNone);
  else
    obj := RaiseUseNewPlainList(aItemTypeInfo);
  end;
  // all IList<T> share the same VMT -> assign once
  IList<Byte>(result) := TSynListSpecialized<Byte>({%H-}obj);
end;

class procedure TGenerics.NewLString(aOptions: TSynListOptions;
  aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; var result);
begin
  IList<RawByteString>(result) := TSynListSpecialized<RawByteString>.Create(
    aOptions, aDynArrayTypeInfo, aItemTypeInfo, ptNone); // may be RawUtf8/RawJson
end;

class procedure TGenerics.NewWString(aOptions: TSynListOptions;
  aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; var result);
begin
  IList<WideString>(result) := TSynListSpecialized<WideString>.Create(
    aOptions, aDynArrayTypeInfo, aItemTypeInfo, ptWideString);
end;

class procedure TGenerics.NewUString(aOptions: TSynListOptions;
  aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; var result);
begin
  IList<UnicodeString>(result) := TSynListSpecialized<UnicodeString>.Create(
    aOptions, aDynArrayTypeInfo, aItemTypeInfo, ptUnicodeString);
end;

class procedure TGenerics.NewInterface(aOptions: TSynListOptions;
  aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; var result);
begin
  IList<IInterface>(result) := TSynListSpecialized<IInterface>.Create(
    aOptions, aDynArrayTypeInfo, aItemTypeInfo, ptInterface);
end;

class procedure TGenerics.NewVariant(aOptions: TSynListOptions;
  aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; var result);
begin
  IList<Variant>(result) := TSynListSpecialized<Variant>.Create(
    aOptions, aDynArrayTypeInfo, aItemTypeInfo, ptVariant);
end;

class function TGenerics.NewList<T>(aOptions: TSynListOptions;
  aDynArrayTypeInfo: PRttiInfo): IList<T>;
begin
  // since Delphi XE7 or FPC 3.2: reuse some main TSynListSpecialized<> types
  // to reduce code size - ptNone below will use RTTI at runtime for process
  case GetTypeKind(T) of  // intrinsic for minimal code generation
    tkInteger, tkInt64, tkChar, tkWChar, tkEnumeration, tkSet,
    tkFloat, tkClass, tkClassRef, tkPointer {$ifdef FPC} , tkQWord {$endif}:
      // reuse TSynListSpecialized<integers> for ordinals
      NewOrdinal(SizeOf(T), aOptions, aDynArrayTypeInfo, TypeInfo(T), result);
    {$ifdef FPC} tkAString {$else} tkLString {$endif FPC}:
      // reuse TSynListSpecialized<Variant> for all AnsiString
      NewLString(aOptions, aDynArrayTypeInfo, TypeInfo(T), result);
    tkWString:
      // reuse TSynListSpecialized<WideString> for all WideString
      NewWString(aOptions, aDynArrayTypeInfo, TypeInfo(T), result);
    tkUString:
      // reuse TSynListSpecialized<UnicodeString> for all UnicodeString
      NewUString(aOptions, aDynArrayTypeInfo, TypeInfo(T), result);
    tkInterface:
      // reuse TSynListSpecialized<IInterface> for all interfaces
      NewInterface(aOptions, aDynArrayTypeInfo, TypeInfo(T), result);
    tkVariant:
      // reuse TSynListSpecialized<Variant> for Variant
      NewVariant(aOptions, aDynArrayTypeInfo, TypeInfo(T), result);
    tkRecord, tkArray {$ifdef FPC} , tkObject {$endif}:
      if IsManagedType(T) then
        RaiseUseNewPlainList(TypeInfo(T))
      else
        // reuse TSynListSpecialized<integers> for simple types like TGUID
        NewOrdinal(SizeOf(T), aOptions, aDynArrayTypeInfo, TypeInfo(T), result);
  else
    // even if NewPlainList<T>() is not called nor used, it would be generated
    // with its full TSynListSpecialized<T> for no benefit but exe bloating
    // -> explicit abort at runtime to let the user fix the code ASAP
    RaiseUseNewPlainList(TypeInfo(T));
  end;
end;

{$else}

class function TGenerics.NewList<T>(aOptions: TSynListOptions;
  aDynArrayTypeInfo: PRttiInfo): IList<T>;
begin
  // oldest Delphi will generate bloated code for each specific type
  result := TSynListSpecialized<T>.Create(
    aOptions, aDynArrayTypeInfo, TypeInfo(T), ptNone);
end;

{$endif HASGETTYPEKIND}

class function TGenerics.NewPlainList<T>(aOptions: TSynListOptions;
  aDynArrayTypeInfo: PRttiInfo): IList<T>;
begin
  result := TSynListSpecialized<T>.Create(
    aOptions, aDynArrayTypeInfo, TypeInfo(T), ptNone);
end;

class function TGenerics.NewKeyValue<TKey, TValue>(
  aOptions: TSynKeyValueOptions; aKeyDynArrayTypeInfo: PRttiInfo;
  aValueDynArrayTypeInfo: PRttiInfo; aTimeoutSeconds: cardinal;
  aCompressAlgo: TAlgoCompress; aHasher: THasher): IKeyValue<TKey, TValue>;
var
  ctx: TNewSynKeyValueContext;
begin
  ctx.Options := aOptions;
  ctx.KeyItemTypeInfo := TypeInfo(TKey);
  ctx.ValueItemTypeInfo := TypeInfo(TValue);
  ctx.KeyArrayTypeInfo := aKeyDynArrayTypeInfo;
  ctx.ValueArrayTypeInfo := aValueDynArrayTypeInfo;
  ctx.Timeout := aTimeOutSeconds;
  ctx.Compress := aCompressAlgo;
  ctx.Hasher := aHasher;
  {$ifdef HASGETTYPEKIND}
  case GetTypeKind(TKey) of  // intrinsic for minimal code generation
    tkInteger, tkInt64, tkChar, tkWChar, tkEnumeration, tkSet,
    tkFloat, tkClass, tkClassRef, tkPointer {$ifdef FPC} , tkQWord {$endif}:
      case GetTypeKind(TValue) of
        tkInteger, tkInt64, tkChar, tkWChar, tkEnumeration, tkSet,
        tkFloat, tkClass, tkClassRef, tkPointer {$ifdef FPC} , tkQWord {$endif}:
          NewOrdinalOrdinal(ctx, SizeOf(TKey), SizeOf(TValue), result);
        {$ifdef FPC} tkAString {$else} tkLString {$endif FPC}:
          NewOrdinalLString(ctx, SizeOf(TKey), result);
        tkWString:
          NewOrdinalWString(ctx, SizeOf(TKey), result);
        tkUString:
          NewOrdinalUString(ctx, SizeOf(TKey), result);
        tkInterface:
          NewOrdinalInterface(ctx, SizeOf(TKey), result);
        tkVariant:
          NewOrdinalVariant(ctx, SizeOf(TKey), result);
        tkRecord, tkArray {$ifdef FPC} , tkObject {$endif}:
          if IsManagedType(TValue) then
            RaiseUseNewPlainKeyValue(ctx)
          else
            NewOrdinalOrdinal(ctx, SizeOf(TKey), SizeOf(TValue), result);
      else
        RaiseUseNewPlainKeyValue(ctx);
      end;
    {$ifdef FPC} tkAString {$else} tkLString {$endif FPC}:
      case GetTypeKind(TValue) of
        tkInteger, tkInt64, tkChar, tkWChar, tkEnumeration, tkSet,
        tkFloat, tkClass, tkClassRef, tkPointer {$ifdef FPC} , tkQWord {$endif}:
          NewLStringOrdinal(ctx, SizeOf(TValue), result);
        {$ifdef FPC} tkAString {$else} tkLString {$endif FPC},
        tkWString, tkUString, tkInterface, tkVariant:
          NewLStringValue(ctx, GetTypeKind(TValue), result);
        tkRecord, tkArray {$ifdef FPC} , tkObject {$endif}:
          if IsManagedType(TValue) then
            RaiseUseNewPlainKeyValue(ctx)
          else
            NewLStringOrdinal(ctx, SizeOf(TValue), result);
      else
        RaiseUseNewPlainKeyValue(ctx);
      end;
    tkWString:
      case GetTypeKind(TValue) of
        tkInteger, tkInt64, tkChar, tkWChar, tkEnumeration, tkSet,
        tkFloat, tkClass, tkClassRef, tkPointer {$ifdef FPC} , tkQWord {$endif}:
          NewWStringOrdinal(ctx, SizeOf(TValue), result);
        {$ifdef FPC} tkAString {$else} tkLString {$endif FPC},
        tkWString, tkUString, tkInterface, tkVariant:
          NewWStringValue(ctx, GetTypeKind(TValue), result);
        tkRecord, tkArray {$ifdef FPC} , tkObject {$endif}:
          if IsManagedType(TValue) then
            RaiseUseNewPlainKeyValue(ctx)
          else
            NewWStringOrdinal(ctx, SizeOf(TValue), result);
      else
        RaiseUseNewPlainKeyValue(ctx);
      end;
    tkUString:
      case GetTypeKind(TValue) of
        tkInteger, tkInt64, tkChar, tkWChar, tkEnumeration, tkSet,
        tkFloat, tkClass, tkClassRef, tkPointer {$ifdef FPC} , tkQWord {$endif}:
          NewUStringOrdinal(ctx, SizeOf(TValue), result);
        {$ifdef FPC} tkAString {$else} tkLString {$endif FPC},
        tkWString, tkUString, tkInterface, tkVariant:
          NewUStringValue(ctx, GetTypeKind(TValue), result);
        tkRecord, tkArray {$ifdef FPC} , tkObject {$endif}:
          if IsManagedType(TValue) then
            RaiseUseNewPlainKeyValue(ctx)
          else
            NewUStringOrdinal(ctx, SizeOf(TValue), result);
      else
        RaiseUseNewPlainKeyValue(ctx);
      end;
    tkInterface:
      case GetTypeKind(TValue) of
        tkInteger, tkInt64, tkChar, tkWChar, tkEnumeration, tkSet,
        tkFloat, tkClass, tkClassRef, tkPointer {$ifdef FPC} , tkQWord {$endif}:
          NewInterfaceOrdinal(ctx, SizeOf(TValue), result);
        {$ifdef FPC} tkAString {$else} tkLString {$endif FPC},
        tkWString, tkUString, tkInterface, tkVariant:
          NewWStringValue(ctx, GetTypeKind(TValue), result);
        tkRecord, tkArray {$ifdef FPC} , tkObject {$endif}:
          if IsManagedType(TValue) then
            RaiseUseNewPlainKeyValue(ctx)
          else
            NewInterfaceOrdinal(ctx, SizeOf(TValue), result);
      else
        RaiseUseNewPlainKeyValue(ctx);
      end;
    tkVariant:
      case GetTypeKind(TValue) of
        tkInteger, tkInt64, tkChar, tkWChar, tkEnumeration, tkSet,
        tkFloat, tkClass, tkClassRef, tkPointer {$ifdef FPC} , tkQWord {$endif}:
          NewVariantOrdinal(ctx, SizeOf(TValue), result);
        {$ifdef FPC} tkAString {$else} tkLString {$endif FPC},
        tkWString, tkUString, tkInterface, tkVariant:
          NewVariantValue(ctx, GetTypeKind(TValue), result);
        tkRecord, tkArray {$ifdef FPC} , tkObject {$endif}:
          if IsManagedType(TValue) then
            RaiseUseNewPlainKeyValue(ctx)
          else
            NewVariantOrdinal(ctx, SizeOf(TValue), result);
      else
        RaiseUseNewPlainKeyValue(ctx);
      end;
  else
    RaiseUseNewPlainKeyValue(ctx);
  end;
  {$else}
  // oldest Delphi will generate bloated code for each specific type
  result := TSynKeyValueSpecialized<TKey, TValue>.Create(ctx);
  {$endif HASGETTYPEKIND}
end;

class function TGenerics.NewPlainKeyValue<TKey, TValue>(
  aOptions: TSynKeyValueOptions; aKeyDynArrayTypeInfo: PRttiInfo;
  aValueDynArrayTypeInfo: PRttiInfo; aTimeoutSeconds: cardinal;
  aCompressAlgo: TAlgoCompress; aHasher: THasher): IKeyValue<TKey, TValue>;
var
  ctx: TNewSynKeyValueContext;
begin
  ctx.Options := aOptions;
  ctx.KeyItemTypeInfo := TypeInfo(TKey);
  ctx.ValueItemTypeInfo := TypeInfo(TValue);
  ctx.KeyArrayTypeInfo := aKeyDynArrayTypeInfo;
  ctx.ValueArrayTypeInfo := aValueDynArrayTypeInfo;
  ctx.Timeout := aTimeOutSeconds;
  ctx.Compress := aCompressAlgo;
  ctx.Hasher := aHasher;
  result := TSynKeyValueSpecialized<TKey, TValue>.Create(ctx);
end;

{$else}

implementation

{$endif HASGENERICS} // do-nothing unit on oldest compilers



end.
